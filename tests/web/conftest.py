import pytest
from unittest.mock import patch
from django.test.utils import override_settings


@pytest.fixture(scope="function", autouse=True)
def temp_media_root(tmp_path_factory):
    """
    Create a temporary media root for each test function.

    Using function scope ensures each test gets a clean media directory,
    and autouse=True ensures it's automatically applied to all tests.
    """
    media_dir = tmp_path_factory.mktemp("media")
    with override_settings(MEDIA_ROOT=media_dir):
        yield media_dir
    # Pytest will automatically clean up the tmp_path_factory directories


def add_dynamic_technology_fields(form_data, technologies=None):
    """Add dynamic technology fields to form data for testing.

    These fields simulate what HTMX would generate dynamically in the browser.
    """
    if technologies is None:
        technologies = ["BF", "BOF", "EAF", "DRING", "DRIH2EAF", "ESF", "MOE"]

    for tech in technologies:
        # Add fields that would be generated by HTMX
        form_data[f"tech_{tech}_allowed"] = "true"
        form_data[f"tech_{tech}_from_year"] = "2025"
        # to_year is optional and typically empty
        form_data[f"tech_{tech}_to_year"] = ""

    return form_data


@pytest.fixture
def valid_modelrun_form_data(ready_data_preparation):
    """Valid form data for ModelRunCreateForm with dynamic technology fields."""
    base_data = {
        "data_preparation": ready_data_preparation.id,
        "start_year": 2025,
        "end_year": 2026,
        "plant_lifetime": 20,  # Added required field
        "scrap_generation_scenario": "circular_economy",
        # Demand and circularity
        "total_steel_demand_scenario": "business_as_usual",
        "green_steel_demand_scenario": "business_as_usual",
        "circularity_file": "",
        # Trade and emissions
        "trade_scenario": "current_policies",
        "emissions_boundary": "cradle_to_gate",
        # Carbon tax
        "enable_carbon_tax": False,
        "carbon_tax_amount": 0,
        # Capital costs
        "capital_cost_scenario": "medium",
        "wacc": 8,
        # Geospatial
        "baseload_coverage": "not_included",
        "grid_power_option": "not_included",
        "infrastructure_buildout": "",
        "transport_costs": "",
        "land_use": "",
    }

    # Add dynamic technology fields that would come from HTMX
    return add_dynamic_technology_fields(base_data)


@pytest.fixture
def mock_technology_extraction():
    """Mock the _extract_technology_settings function to return valid data."""

    def extract_technology_settings_side_effect(request, data_preparation, form):
        """Extract technology settings from form data dynamically."""
        tech_settings = {}

        # Default technologies
        default_techs = {
            "BF": True,
            "BOF": True,
            "EAF": True,
            "DRING": True,
            "DRIH2EAF": False,
            "ESF": False,
            "MOE": False,
            "DRI": True,
            "DRIH2": True,
            "BFBOF": True,
            "DRINGEAF": True,
            "ESFEAF": False,
        }

        # Build settings from form data
        for tech_name, default_allowed in default_techs.items():
            # Start with defaults
            tech_settings[tech_name] = {
                "allowed": default_allowed,
                "from_year": 2025,
                "to_year": None,
            }

            # Check if form has dynamic field for this technology
            if hasattr(form, "data"):
                # For checkboxes: present with value means enabled, absent means disabled
                allowed_field = f"tech_{tech_name}_allowed"
                from_field = f"tech_{tech_name}_from_year"

                # If from_year is present but allowed is not, technology is disabled
                has_from_year = from_field in form.data
                has_allowed = allowed_field in form.data

                if has_from_year and not has_allowed:
                    # from_year present but no checkbox = disabled
                    tech_settings[tech_name]["allowed"] = False
                elif has_allowed:
                    # Checkbox is present, check its value
                    value = form.data[allowed_field]
                    if value in ["true", "on", True]:
                        tech_settings[tech_name]["allowed"] = True
                    elif value in ["false", "off", False]:
                        tech_settings[tech_name]["allowed"] = False

                # Check for from_year (already defined above)
                if from_field in form.data and form.data[from_field]:
                    try:
                        tech_settings[tech_name]["from_year"] = int(form.data[from_field])
                    except (ValueError, TypeError):
                        pass

                # Check for to_year
                to_field = f"tech_{tech_name}_to_year"
                if to_field in form.data and form.data[to_field]:
                    try:
                        tech_settings[tech_name]["to_year"] = int(form.data[to_field])
                    except (ValueError, TypeError):
                        pass

        return tech_settings

    with patch("steeloweb.views._extract_technology_settings") as mock:
        mock.side_effect = extract_technology_settings_side_effect
        yield mock
